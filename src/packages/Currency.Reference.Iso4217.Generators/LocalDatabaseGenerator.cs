using System.Reflection;
using System.Text;
using Currency.Reference.Iso4217.Generators.Handlers;
using Currency.Reference.Iso4217.Generators.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
namespace Currency.Reference.Iso4217.Generators;

[Generator]
public class LocalDatabaseGenerator : BaseIncrementalGenerator
{
    public override string HintName => "LocalDatabase.g.cs";

    private const string StubSource = """
                                      // <auto-generated>
                                      //     This file was generated by Currency.Reference.Iso4217.Generators source generator.
                                      //     Do not modify this file manually.
                                      // </auto-generated>
                                      #nullable enable
                                      using System.Collections.Generic;
                                      using Currency.Reference.Iso4217.Models;
                                      namespace Currency.Reference.Iso4217
                                      {
                                          /// <summary> Currency information for codes ISO4217 </summary>
                                          internal static class LocalDatabase
                                          {
                                              /// <summary> Actual currency information for codes ISO4217 </summary>
                                              public static IReadOnlyList<Models.Currency> ActualCurrencies = new List<Models.Currency>();
                                              
                                              /// <summary> Currency historical information for codes ISO4217 </summary>
                                              public static IReadOnlyList<Models.Currency> HistoricalCurrencies = new List<Models.Currency>();
                                          }
                                      }
                                      """;

    public override void Initialize(IncrementalGeneratorInitializationContext context)
    {
        ErrorFactory.Clear();
        var jsonProvider = context.CompilationProvider.Select((_, _) =>
        {
            try
            {
                return LoadJsonResources(Assembly.GetExecutingAssembly());
            }
            catch (Exception ex)
            {
                return ($"{Constants.ErrorMark}:{ex.Message}", $"{Constants.ErrorMark}:{ex.Message}", $"{Constants.ErrorMark}:{ex.Message}");
            }
        });
        context.RegisterSourceOutput(jsonProvider, (spc, tuple) => { GenerateSourceOutput(tuple, spc); });
    }

    private void GenerateSourceOutput((string, string, string) tuple, SourceProductionContext spc)
    {
        try
        {
            var (originalJson, replacementJson, historicalJson) = tuple;
            if (originalJson.StartsWith(Constants.ErrorMark) || replacementJson.StartsWith(Constants.ErrorMark) ||
                historicalJson.StartsWith(Constants.ErrorMark))
            {
                if (originalJson.StartsWith(Constants.ErrorMark))
                    ErrorFactory.Create(new ErrorDescription
                    {
                        DiagnosticDescriptor = new DiagnosticDescriptor(
                            id: DiagnosticDescriptors.ResourceLoadErrorId,
                            title: Constants.DiagnosticsTitle,
                            messageFormat: $"Failed to load original resource: {originalJson.Substring(9)}",
                            category: string.Empty,
                            defaultSeverity: DiagnosticSeverity.Error,
                            isEnabledByDefault: true),
                        GeneratorType = GeneratorType.Database
                    });
                if (replacementJson.StartsWith(Constants.ErrorMark))
                    ErrorFactory.Create(
                        new ErrorDescription
                        {
                            DiagnosticDescriptor = new DiagnosticDescriptor(
                                id: DiagnosticDescriptors.ResourceLoadErrorId,
                                title: Constants.DiagnosticsTitle,
                                messageFormat: $"Failed to load historical resource: {historicalJson.Substring(9)}",
                                category: string.Empty,
                                defaultSeverity: DiagnosticSeverity.Error,
                                isEnabledByDefault: true),
                            GeneratorType = GeneratorType.Database
                        });
                if (historicalJson.StartsWith(Constants.ErrorMark))
                    ErrorFactory.Create(
                        new ErrorDescription
                        {
                            DiagnosticDescriptor = new DiagnosticDescriptor(
                                id: DiagnosticDescriptors.ResourceLoadErrorId,
                                title: Constants.DiagnosticsTitle,
                                messageFormat:
                                $"Failed to load replacement's resource: {historicalJson.Substring(9)}",
                                category: string.Empty,
                                defaultSeverity: DiagnosticSeverity.Error,
                                isEnabledByDefault: true),
                            GeneratorType = GeneratorType.Database
                        });
                AddStubIfErrors(spc, HintName, StubSource, GeneratorType.Database);
                return;
            }

            var loader = new CurrencyLoader(originalJson, replacementJson, historicalJson);
            var sb = CreateSourceBuilder(
                Constants.GeneratorName,
                Constants.DefaultNamespace,
                ["System.Collections.Generic", "Currency.Reference.Iso4217.Models"]
            );
            sb.AppendLine("    /// <summary> Currency information for codes ISO4217 </summary>")
                .AppendLine("    internal static class LocalDatabase")
                .AppendLine("    {");

            if (string.IsNullOrEmpty(loader.ActualCurrencyData.PublishedDate))
                sb.AppendLine(
                    "        /// <summary> Actual currency information for codes ISO4217 </summary>");
            else
                sb.AppendLine("        /// <summary>")
                    .AppendLine("        /// Actual currency information for codes ISO4217")
                    .AppendLine($"        /// Last published at {loader.ActualCurrencyData.PublishedDate}.")
                    .AppendLine("        /// </summary>");

            sb.AppendLine(
                    "        public static IReadOnlyList<Models.Currency> ActualCurrencies = new List<Models.Currency>()")
                .AppendLine(
                    "        {");
            foreach (var c in loader.ActualCurrencyData.Currencies)
            {
                var currencyType = $", CurrencyType.{c.CurrencyType}";
                var isHistorical = c.IsHistoric ? "true" : "false";
                sb.AppendLine(
                    $"            new(\"{c.Code}\", \"{c.Name}\", \"{c.Country}\", \"{c.NumericCode}\", {isHistorical}, {ParseWithdrawalDate(c.WithdrawalDate)}{currencyType}),");
            }

            sb.AppendLine("        };");

            if (string.IsNullOrEmpty(loader.HistoricalCurrencyData.PublishedDate))
                sb.AppendLine(
                    "        /// <summary> Currency historical information for codes ISO4217 </summary>");
            else
                sb.AppendLine("        /// <summary>")
                    .AppendLine("        /// Currency historical information for codes ISO4217")
                    .AppendLine($"        /// Last published at {loader.HistoricalCurrencyData.PublishedDate}.")
                    .AppendLine("        /// </summary>");
            
            sb.AppendLine(
                    "        public static IReadOnlyList<Models.Currency> HistoricalCurrencies = new List<Models.Currency>()")
                .AppendLine(
                    "        {");
            foreach (var c in loader.HistoricalCurrencyData.Currencies)
            {
                var isHistorical = c.IsHistoric ? "true" : "false";
                sb.AppendLine(
                    $"            new(\"{c.Code}\", \"{c.Name}\", \"{c.Country}\", \"{c.NumericCode}\", {isHistorical}, {ParseWithdrawalDate(c.WithdrawalDate)}, null),");
            }

            sb.AppendLine("        };")
                .AppendLine("    }")
                .AppendLine("}");
            spc.AddSource(HintName, SourceText.From(sb.ToString(), Encoding.UTF8));
        }
        catch (Exception ex)
        {
            ErrorFactory.Create(new ErrorDescription()
            {
                DiagnosticDescriptor = new DiagnosticDescriptor(
                    id: DiagnosticDescriptors.UnexpectedErrorId,
                    title: Constants.DiagnosticsTitle,
                    messageFormat: $"Unexpected exception: {ex.Message}",
                    category: string.Empty,
                    defaultSeverity: DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                GeneratorType = GeneratorType.Database
            });
            AddStubIfErrors(spc, HintName, StubSource, GeneratorType.Database);
        }
    }

    private static string ParseWithdrawalDate(string? raw)
    {
        if (string.IsNullOrWhiteSpace(raw))
            return " null";
        return DateTime.TryParseExact(raw, "yyyy-MM", null, System.Globalization.DateTimeStyles.None, out var dt)
            ? $" new DateOnly({dt.Year}, {dt.Month}, 1)"
            : " null";
    }
}